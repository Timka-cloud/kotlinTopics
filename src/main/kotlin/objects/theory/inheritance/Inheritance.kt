package objects.theory.inheritance
// shift + shift open search area
/*
Для расширения существующего функционала (создания нового класса на основе другого класса) можно использовать несколько подходов:
– если объект подходит по смыслу “is-a (“является”), то применяем наследование (дочерний класс -> родительский класс)
– если объект подходит по смыслу “has-a” (“содержит”), то применяем композицию (ассоциация)


Как и в Java:
– можно создавать дочерние классы от любого другого класса
– дочерний класс может иметь только одного родителя
– все классы по-умолчанию наследуются от общего класса-родителя Object


По-умолчанию все классы в Kotlin не разрешают наследование (final class в Java) – важное отличие от Java.
Чтобы разрешить наследование – добавляется слово “open”
 */



open class Shape { // open чтобы можно было наследоваться от класса

    open fun draw() { // чтобы дочерние классы могли переопределить метод - нужно добавить ключевое слово open (без него метод
        // по умолчанию стоит final)
        println("draw shape")
    }
}

// дочерний класс круг - является фигурой, подходит по смыслу is a
// для наследование пишем просто символ ":"

open class Circle : Shape() { // пустые скобки означают, что ссылаемся на родительский класс без параметров

    // доп свои методы, которые характерны только для Circle
    fun calcRadius() {
        super.draw() // вызов родительского метода
        println("calc radius")
    }
}

